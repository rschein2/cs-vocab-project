#deck:CS Vocab::Git
#separator:tab
#html:true
#tags column:3

How do you initialize a new Git repository in your current directory?	<strong>Command:</strong> <code>git init</code><br><br>        <p><strong>Explanation:</strong> This creates a new <code>.git</code> subdirectory in your current folder, which contains all the metadata and object database for the repository.</p><br><br>        <p><strong>Common variations:</strong></p><br>        <ul><br>            <li><code>git init project-name</code> - creates a new directory with that name and initializes it</li><br>            <li><code>git init --bare</code> - creates a bare repository (no working directory, used for remote repos)</li><br>        </ul>	cs git EN
You've made changes to 3 files but only want to commit 2 of them. What's the workflow?	<strong>Commands:</strong><br>        <pre><code>git add file1.txt file2.txt<br>git commit -m "Your message"</code></pre><br><br>        <p><strong>Why:</strong> The staging area (index) lets you craft precise commits. You can stage only the changes that belong together logically, even if you've modified other files.</p><br><br>        <p><strong>Alternatives:</strong></p><br>        <ul><br>            <li><code>git add -p</code> - interactively stage parts of files (hunks)</li><br>            <li><code>git commit file1.txt file2.txt -m "message"</code> - bypass staging, commit specific files directly</li><br>        </ul>	cs git EN
You created a feature branch, made several commits, and now want to integrate it into main. You want a clean, linear history. Should you merge or rebase? What's the command?	<strong>Answer:</strong> <strong>Rebase</strong><br><br>        <strong>Command:</strong><br>        <pre><code>git checkout main<br>git pull<br>git checkout feature-branch<br>git rebase main</code></pre><br><br>        <p><strong>Why rebase:</strong> Rebasing replays your commits on top of the latest main branch, creating a linear history without merge commits. This makes the history cleaner and easier to follow.</p><br><br>        <p><strong>When to merge instead:</strong></p><br>        <ul><br>            <li>The branch is already pushed and shared with others (rebasing rewrites history)</li><br>            <li>You want to preserve the exact chronological history</li><br>            <li>Command: <code>git merge feature-branch</code> (from main)</li><br>        </ul><br><br>        <p><strong>Pro tip:</strong> Never rebase commits that have been pushed to a shared branch!</p>	cs git EN
You accidentally committed sensitive data (API key) in your last commit. The commit hasn't been pushed yet. How do you remove it?	<strong>Command:</strong> <code>git reset --soft HEAD~1</code><br><br>        <p><strong>Why:</strong> This undoes the last commit but keeps your changes staged. You can now remove the sensitive file, add the file to <code>.gitignore</code>, and recommit.</p><br><br>        <p><strong>Complete workflow:</strong></p><br>        <pre><code>git reset --soft HEAD~1<br># Remove sensitive data from the file<br>echo "config.env" >> .gitignore<br>git add .gitignore<br>git commit -m "Your corrected commit"</code></pre><br><br>        <p><strong>Other reset options:</strong></p><br>        <ul><br>            <li><code>git reset --mixed HEAD~1</code> - default, unstages changes too</li><br>            <li><code>git reset --hard HEAD~1</code> - DANGEROUS: deletes changes entirely</li><br>        </ul>	cs git EN
How do you view the commit history in a compact, readable format showing the branch structure?	<strong>Command:</strong> <code>git log --oneline --graph --all</code><br><br>        <p><strong>Why each flag:</strong></p><br>        <ul><br>            <li><code>--oneline</code> - shows each commit on one line (abbreviated hash + message)</li><br>            <li><code>--graph</code> - draws ASCII graph showing branch structure</li><br>            <li><code>--all</code> - shows all branches, not just current one</li><br>        </ul><br><br>        <p><strong>Useful variations:</strong></p><br>        <ul><br>            <li><code>git log --oneline -10</code> - show last 10 commits</li><br>            <li><code>git log --author="name"</code> - filter by author</li><br>            <li><code>git log --since="2 weeks ago"</code> - time-based filtering</li><br>        </ul>	cs git EN
You're working on a feature but need to urgently fix a bug on main. Your working directory has uncommitted changes. What do you do?	<strong>Answer:</strong> <strong>Stash your changes</strong><br><br>        <strong>Commands:</strong><br>        <pre><code>git stash<br>git checkout main<br># Fix the bug, commit<br>git checkout feature-branch<br>git stash pop</code></pre><br><br>        <p><strong>Why:</strong> <code>git stash</code> temporarily saves your uncommitted changes and reverts your working directory to the last commit. This lets you switch branches cleanly without committing half-done work.</p><br><br>        <p><strong>Stash options:</strong></p><br>        <ul><br>            <li><code>git stash save "description"</code> - add a message to identify the stash</li><br>            <li><code>git stash list</code> - see all stashed changes</li><br>            <li><code>git stash apply</code> - apply stash but keep it in the stash list</li><br>            <li><code>git stash pop</code> - apply and remove from stash list</li><br>        </ul>	cs git EN
How do you create a new branch and immediately switch to it?	<strong>Command:</strong> <code>git checkout -b branch-name</code><br><br>        <p><strong>Or (newer syntax):</strong> <code>git switch -c branch-name</code></p><br><br>        <p><strong>Why:</strong> This is shorthand for two commands:<br>        <pre><code>git branch branch-name<br>git checkout branch-name</code></pre><br>        </p><br><br>        <p><strong>When to use each:</strong></p><br>        <ul><br>            <li><code>git checkout -b</code> - traditional, widely supported</li><br>            <li><code>git switch -c</code> - newer, clearer semantics (Git 2.23+)</li><br>            <li>Both do the same thing!</li><br>        </ul>	cs git EN
You need to undo changes to a specific file in your working directory, reverting it to the last committed state. What's the command?	<strong>Command:</strong> <code>git checkout -- filename</code><br><br>        <p><strong>Or (newer syntax):</strong> <code>git restore filename</code></p><br><br>        <p><strong>Warning:</strong> This permanently deletes your uncommitted changes to that file! Make sure you really want to discard them.</p><br><br>        <p><strong>Related commands:</strong></p><br>        <ul><br>            <li><code>git restore --staged filename</code> - unstage a file (keep changes in working directory)</li><br>            <li><code>git checkout .</code> - discard ALL changes in current directory</li><br>            <li><code>git clean -fd</code> - remove untracked files and directories</li><br>        </ul>	cs git EN
How do you see what changes you've made before staging them?	<strong>Command:</strong> <code>git diff</code><br><br>        <p><strong>Why:</strong> Shows line-by-line differences between your working directory and the staging area. Essential for reviewing your work before committing.</p><br><br>        <p><strong>Common variations:</strong></p><br>        <ul><br>            <li><code>git diff</code> - unstaged changes</li><br>            <li><code>git diff --staged</code> - staged changes (what will be committed)</li><br>            <li><code>git diff HEAD</code> - all changes (staged + unstaged)</li><br>            <li><code>git diff main..feature</code> - compare two branches</li><br>            <li><code>git diff filename</code> - changes in specific file</li><br>        </ul>	cs git EN
You merged a feature branch into main but now realize the feature isn't ready. How do you undo the merge? (Not pushed yet)	<strong>Command:</strong> <code>git reset --hard HEAD~1</code><br><br>        <p><strong>Why:</strong> Since the merge created a new commit, resetting to the previous commit (HEAD~1) undoes the merge. <code>--hard</code> also discards all changes in your working directory.</p><br><br>        <p><strong>If already pushed:</strong></p><br>        <pre><code>git revert -m 1 HEAD</code></pre><br>        <p>This creates a new commit that undoes the merge (safer for shared branches). The <code>-m 1</code> flag specifies which parent to revert to (usually 1 for the main branch).</p><br><br>        <p><strong>Remember:</strong> Only use <code>reset --hard</code> on commits that haven't been shared!</p>	cs git EN
How do you view the changes introduced by a specific commit?	<strong>Command:</strong> <code>git show commit-hash</code><br><br>        <p><strong>Examples:</strong></p><br>        <ul><br>            <li><code>git show HEAD</code> - show the last commit</li><br>            <li><code>git show HEAD~3</code> - show the commit 3 commits ago</li><br>            <li><code>git show abc1234</code> - show specific commit by hash</li><br>        </ul><br><br>        <p><strong>What it shows:</strong> Commit metadata (author, date, message) plus the diff of changes introduced.</p><br><br>        <p><strong>Related:</strong></p><br>        <ul><br>            <li><code>git show commit-hash:filename</code> - show specific file at that commit</li><br>            <li><code>git log -p</code> - show commit history with diffs</li><br>        </ul>	cs git EN
You want to take just one specific commit from another branch and apply it to your current branch. What's the command?	<strong>Answer:</strong> <strong>Cherry-pick</strong><br><br>        <strong>Command:</strong> <code>git cherry-pick commit-hash</code><br><br>        <p><strong>Why:</strong> Cherry-picking applies the changes from a specific commit to your current branch as a new commit. Useful when you want just one fix from another branch without merging everything.</p><br><br>        <p><strong>Example scenario:</strong></p><br>        <pre><code># You're on main and want commit abc123 from feature-branch<br>git checkout main<br>git cherry-pick abc123</code></pre><br><br>        <p><strong>Options:</strong></p><br>        <ul><br>            <li><code>git cherry-pick abc123 def456</code> - pick multiple commits</li><br>            <li><code>git cherry-pick --no-commit abc123</code> - apply changes but don't commit yet</li><br>            <li><code>git cherry-pick --abort</code> - cancel if there are conflicts</li><br>        </ul>	cs git EN
You just made a commit but forgot to include one file. How do you add it to the last commit without creating a new one?	<strong>Command:</strong><br>        <pre><code>git add forgotten-file.txt<br>git commit --amend --no-edit</code></pre><br><br>        <p><strong>Why:</strong> <code>--amend</code> modifies the most recent commit instead of creating a new one. <code>--no-edit</code> keeps the same commit message.</p><br><br>        <p><strong>To also change the message:</strong></p><br>        <pre><code>git add forgotten-file.txt<br>git commit --amend -m "New message"</code></pre><br><br>        <p><strong>Warning:</strong> Never amend commits that have been pushed to a shared branch! Amending rewrites history.</p><br><br>        <p><strong>If already pushed (and you're sure no one else pulled it):</strong></p><br>        <pre><code>git push --force-with-lease</code></pre>	cs git EN
How do you download changes from a remote repository without merging them into your current branch?	<strong>Command:</strong> <code>git fetch</code><br><br>        <p><strong>Why:</strong> Fetching updates your local copy of remote branches (like <code>origin/main</code>) but doesn't touch your working directory or current branch. Safe for checking what's new before integrating.</p><br><br>        <p><strong>What it does:</strong></p><br>        <ul><br>            <li>Downloads commits, files, and refs from remote</li><br>            <li>Updates remote-tracking branches (origin/main, origin/feature, etc.)</li><br>            <li>Your local branches stay unchanged</li><br>        </ul><br><br>        <p><strong>Common workflow:</strong></p><br>        <pre><code>git fetch<br>git log HEAD..origin/main  # See what's new<br>git merge origin/main       # Merge when ready</code></pre><br><br>        <p><strong>Alternatives:</strong></p><br>        <ul><br>            <li><code>git fetch origin branch-name</code> - fetch specific branch</li><br>            <li><code>git pull</code> - fetch + merge in one command</li><br>        </ul>	cs git EN
What's the difference between <code>git fetch</code> and <code>git pull</code>? When would you use each?	<strong>Commands:</strong><br>        <ul><br>            <li><code>git fetch</code> - download remote changes, don't merge</li><br>            <li><code>git pull</code> - download remote changes AND merge into current branch</li><br>        </ul><br><br>        <p><strong>git pull is actually:</strong></p><br>        <pre><code>git fetch<br>git merge origin/current-branch</code></pre><br><br>        <p><strong>When to use fetch:</strong></p><br>        <ul><br>            <li>You want to review changes before merging</li><br>            <li>You're working on something and aren't ready to integrate</li><br>            <li>You want to see what others have done</li><br>        </ul><br><br>        <p><strong>When to use pull:</strong></p><br>        <ul><br>            <li>You're ready to merge remote changes immediately</li><br>            <li>You trust the remote branch (like pulling main)</li><br>            <li>Quick workflow: <code>git pull origin main</code></li><br>        </ul>	cs git EN
You're merging a branch and hit a conflict. How do you see which files have conflicts?	<strong>Command:</strong> <code>git status</code><br><br>        <p><strong>Why:</strong> During a merge conflict, <code>git status</code> shows files with conflicts under "Unmerged paths" or "both modified".</p><br><br>        <p><strong>Conflict resolution workflow:</strong></p><br>        <pre><code>git status              # See conflicted files<br># Edit files, resolve conflicts (look for &lt;&lt;&lt;&lt;&lt;&lt;&lt; markers)<br>git add resolved-file.txt<br>git commit              # Complete the merge</code></pre><br><br>        <p><strong>Aborting a merge:</strong></p><br>        <pre><code>git merge --abort</code></pre><br><br>        <p><strong>Other helpful commands:</strong></p><br>        <ul><br>            <li><code>git diff</code> - see conflict markers in detail</li><br>            <li><code>git log --merge</code> - see commits that caused conflict</li><br>            <li><code>git checkout --theirs filename</code> - take their version</li><br>            <li><code>git checkout --ours filename</code> - keep your version</li><br>        </ul>	cs git EN
You accidentally deleted a commit with <code>reset --hard</code>. How do you get it back?	<strong>Command:</strong> <code>git reflog</code><br><br>        <p><strong>Why:</strong> The reflog is Git's safety net - it records every change to HEAD, even commits that seem "deleted". You can find the lost commit hash and restore it.</p><br><br>        <p><strong>Recovery workflow:</strong></p><br>        <pre><code>git reflog                    # Find the lost commit hash<br>git checkout abc1234          # Or git reset --hard abc1234<br># Or create a branch: git branch recovered abc1234</code></pre><br><br>        <p><strong>What reflog shows:</strong> A chronological list of HEAD movements with commit hashes, so you can time-travel to any previous state.</p><br><br>        <p><strong>Examples:</strong></p><br>        <ul><br>            <li><code>git reflog show feature-branch</code> - reflog for specific branch</li><br>            <li><code>git reset --hard HEAD@{5}</code> - go back 5 HEAD movements</li><br>        </ul><br><br>        <p><strong>Note:</strong> Reflog entries expire after ~90 days by default.</p>	cs git EN
How do you see who last modified each line of a file and when?	<strong>Command:</strong> <code>git blame filename</code><br><br>        <p><strong>Why:</strong> Shows line-by-line annotations with commit hash, author, date, and line number. Essential for understanding "who wrote this and why?"</p><br><br>        <p><strong>Example output:</strong></p><br>        <pre><code>abc12345 (Alice 2024-01-15) function calculate() {<br>def67890 (Bob   2024-02-20)   return x + y;<br>abc12345 (Alice 2024-01-15) }</code></pre><br><br>        <p><strong>Useful options:</strong></p><br>        <ul><br>            <li><code>git blame -L 10,20 filename</code> - blame specific line range</li><br>            <li><code>git blame -e filename</code> - show email addresses</li><br>            <li><code>git blame -w filename</code> - ignore whitespace changes</li><br>        </ul><br><br>        <p><strong>Following history:</strong></p><br>        <pre><code>git log -p -S "search term" filename</code></pre><br>        <p>Shows all commits that added/removed "search term" in that file.</p>	cs git EN
You pushed a commit to the remote but realized it has a bug. How do you safely undo it?	<strong>Command:</strong> <code>git revert commit-hash</code><br><br>        <p><strong>Why revert instead of reset:</strong> <code>revert</code> creates a NEW commit that undoes the changes, preserving history. Safe for shared branches since it doesn't rewrite history.</p><br><br>        <p><strong>Workflow:</strong></p><br>        <pre><code>git revert HEAD        # Undo last commit<br>git push</code></pre><br><br>        <p><strong>Or revert older commit:</strong></p><br>        <pre><code>git log                # Find the bad commit hash<br>git revert abc1234<br>git push</code></pre><br><br>        <p><strong>Multiple commits:</strong></p><br>        <pre><code>git revert abc123 def456 ghi789</code></pre><br><br>        <p><strong>Abort if conflicts:</strong></p><br>        <pre><code>git revert --abort</code></pre><br><br>        <p><strong>Remember:</strong> <code>reset</code> for local commits, <code>revert</code> for pushed commits!</p>	cs git EN
How do you create a tag to mark a release (like v1.0.0)?	<strong>Command:</strong> <code>git tag -a v1.0.0 -m "Release version 1.0.0"</code><br><br>        <p><strong>Why:</strong> Tags create permanent bookmarks in history, typically used for releases. <code>-a</code> creates an annotated tag (recommended) with metadata like tagger name and date.</p><br><br>        <p><strong>After creating tag:</strong></p><br>        <pre><code>git push origin v1.0.0</code></pre><br>        <p>Or push all tags: <code>git push --tags</code></p><br><br>        <p><strong>Tag types:</strong></p><br>        <ul><br>            <li><code>git tag v1.0.0</code> - lightweight tag (just a pointer)</li><br>            <li><code>git tag -a v1.0.0 -m "msg"</code> - annotated tag (full object, recommended)</li><br>        </ul><br><br>        <p><strong>Useful commands:</strong></p><br>        <ul><br>            <li><code>git tag</code> - list all tags</li><br>            <li><code>git show v1.0.0</code> - see tag details</li><br>            <li><code>git checkout v1.0.0</code> - checkout code at that tag</li><br>            <li><code>git tag -d v1.0.0</code> - delete local tag</li><br>        </ul>	cs git EN
You have 5 messy commits on your feature branch. How do you combine them into one clean commit before merging?	<strong>Command:</strong> <code>git rebase -i HEAD~5</code><br><br>        <p><strong>Why:</strong> Interactive rebase (<code>-i</code>) lets you edit commit history. You can squash (combine) multiple commits into one, reorder them, edit messages, or drop commits.</p><br><br>        <p><strong>Workflow:</strong></p><br>        <pre><code>git rebase -i HEAD~5<br># In editor, change "pick" to "squash" (or "s") for commits to combine<br># Save and close, then edit the combined commit message</code></pre><br><br>        <p><strong>Interactive rebase commands:</strong></p><br>        <ul><br>            <li><code>pick</code> - keep commit as-is</li><br>            <li><code>squash</code> (or <code>s</code>) - combine with previous commit</li><br>            <li><code>reword</code> (or <code>r</code>) - change commit message</li><br>            <li><code>edit</code> - pause to amend commit</li><br>            <li><code>drop</code> - delete commit</li><br>        </ul><br><br>        <p><strong>Warning:</strong> Only rebase commits that haven't been pushed to shared branches!</p>	cs git EN
How do you list all branches, including remote branches?	<strong>Command:</strong> <code>git branch -a</code><br><br>        <p><strong>Why:</strong> <code>-a</code> shows ALL branches: local branches and remote-tracking branches (like <code>origin/main</code>, <code>origin/feature</code>).</p><br><br>        <p><strong>Branch commands comparison:</strong></p><br>        <ul><br>            <li><code>git branch</code> - list local branches only</li><br>            <li><code>git branch -r</code> - list remote-tracking branches only</li><br>            <li><code>git branch -a</code> - list ALL branches (local + remote)</li><br>            <li><code>git branch -v</code> - verbose (show last commit on each branch)</li><br>        </ul><br><br>        <p><strong>Other useful commands:</strong></p><br>        <ul><br>            <li><code>git branch -d branch-name</code> - delete merged local branch</li><br>            <li><code>git branch -D branch-name</code> - force delete unmerged branch</li><br>            <li><code>git push origin --delete branch-name</code> - delete remote branch</li><br>        </ul>	cs git EN
You cloned a repo and want to work on a remote branch called "feature-x" that already exists. What's the command?	<strong>Command:</strong> <code>git checkout feature-x</code><br><br>        <p><strong>Or:</strong> <code>git switch feature-x</code></p><br><br>        <p><strong>Why it works:</strong> Modern Git automatically creates a local branch tracking the remote branch if the name matches. It's shorthand for:</p><br>        <pre><code>git checkout -b feature-x origin/feature-x</code></pre><br><br>        <p><strong>Full workflow after cloning:</strong></p><br>        <pre><code>git clone &lt;url&gt;<br>git branch -a              # See all remote branches<br>git checkout feature-x     # Create local branch tracking origin/feature-x</code></pre><br><br>        <p><strong>If branch name conflicts or you want to be explicit:</strong></p><br>        <pre><code>git checkout -b local-name origin/remote-branch</code></pre><br><br>        <p><strong>See tracking info:</strong></p><br>        <pre><code>git branch -vv</code></pre>	cs git EN
You want to see which commits are in branch A but not in branch B. What's the command?	<strong>Command:</strong> <code>git log branch-B..branch-A</code><br><br>        <p><strong>Why:</strong> The <code>..</code> syntax shows commits reachable from A but not from B. Essential for reviewing what will be merged.</p><br><br>        <p><strong>Example scenarios:</strong></p><br>        <pre><code>git log main..feature        # What's new in feature?<br>git log origin/main..main    # What haven't I pushed yet?<br>git log HEAD..origin/main    # What will I get if I pull?</code></pre><br><br>        <p><strong>With file changes:</strong></p><br>        <pre><code>git log --oneline main..feature     # Compact view<br>git log -p main..feature            # With diffs</code></pre><br><br>        <p><strong>Symmetric difference (commits in either, but not both):</strong></p><br>        <pre><code>git log --oneline main...feature</code></pre><br>        <p>Note: three dots (<code>...</code>) instead of two!</p>	cs git EN
You staged a file but want to unstage it without losing your changes. What's the command?	<strong>Command:</strong> <code>git restore --staged filename</code><br><br>        <p><strong>Or (older syntax):</strong> <code>git reset HEAD filename</code></p><br><br>        <p><strong>Why:</strong> Removes the file from the staging area but keeps your modifications in the working directory. Useful when you staged something by accident.</p><br><br>        <p><strong>To unstage everything:</strong></p><br>        <pre><code>git restore --staged .<br># Or: git reset HEAD</code></pre><br><br>        <p><strong>Remember the difference:</strong></p><br>        <ul><br>            <li><code>git restore --staged file</code> - unstage (keep changes)</li><br>            <li><code>git restore file</code> - discard changes (DANGER!)</li><br>        </ul><br><br>        <p><strong>Visual:</strong> Staging area â†’ Working directory (changes kept)</p>	cs git EN
How do you change the URL of your remote repository (e.g., switching from HTTPS to SSH)?	<strong>Command:</strong> <code>git remote set-url origin &lt;new-url&gt;</code><br><br>        <p><strong>Example:</strong></p><br>        <pre><code>git remote set-url origin git@github.com:user/repo.git</code></pre><br><br>        <p><strong>Why:</strong> Changes where <code>git push</code> and <code>git pull</code> send/receive data. Common when switching authentication methods or migrating repos.</p><br><br>        <p><strong>Verify the change:</strong></p><br>        <pre><code>git remote -v</code></pre><br>        <p>Shows fetch and push URLs for all remotes.</p><br><br>        <p><strong>Other remote commands:</strong></p><br>        <ul><br>            <li><code>git remote add origin &lt;url&gt;</code> - add a new remote</li><br>            <li><code>git remote remove origin</code> - remove remote</li><br>            <li><code>git remote rename origin upstream</code> - rename remote</li><br>        </ul>	cs git EN
You want to save your current branch state before trying something risky. How do you create a backup branch?	<strong>Command:</strong> <code>git branch backup-branch-name</code><br><br>        <p><strong>Why:</strong> Creates a new branch pointing to your current commit without switching to it. If you mess up, you can always return to this point.</p><br><br>        <p><strong>Workflow for risky operations:</strong></p><br>        <pre><code>git branch backup-before-rebase    # Create backup<br>git rebase -i HEAD~10              # Do risky operation<br># If something goes wrong:<br>git reset --hard backup-before-rebase</code></pre><br><br>        <p><strong>Or create and switch:</strong></p><br>        <pre><code>git checkout -b experiment</code></pre><br><br>        <p><strong>Delete backup when done:</strong></p><br>        <pre><code>git branch -d backup-branch-name</code></pre><br><br>        <p><strong>Tip:</strong> Branches are cheap in Git! Create them liberally.</p>	cs git EN
How do you search through all commits to find when a specific string was added or removed?	<strong>Command:</strong> <code>git log -S "search string"</code><br><br>        <p><strong>Why:</strong> The <code>-S</code> flag (pickaxe) finds commits where the number of occurrences of the string changed. Perfect for tracking when a function, variable, or bug was introduced or removed.</p><br><br>        <p><strong>With file path:</strong></p><br>        <pre><code>git log -S "function_name" -- path/to/file.js</code></pre><br><br>        <p><strong>Show the actual changes:</strong></p><br>        <pre><code>git log -S "search string" -p</code></pre><br><br>        <p><strong>Similar commands:</strong></p><br>        <ul><br>            <li><code>git log -G "regex pattern"</code> - search with regex</li><br>            <li><code>git log --grep="commit message text"</code> - search commit messages</li><br>            <li><code>git log --all --full-history -- path/to/deleted/file</code> - find deleted files</li><br>        </ul>	cs git EN
You have multiple stashes. How do you see the list and apply a specific one?	<strong>Commands:</strong><br>        <pre><code>git stash list              # See all stashes<br>git stash apply stash@{2}   # Apply specific stash</code></pre><br><br>        <p><strong>Why:</strong> You can have multiple stashes stacked up. Each gets an index like <code>stash@{0}</code> (most recent), <code>stash@{1}</code>, etc.</p><br><br>        <p><strong>Example output of list:</strong></p><br>        <pre><code>stash@{0}: WIP on feature: Added button<br>stash@{1}: WIP on main: Fixed typo<br>stash@{2}: WIP on develop: Updated API</code></pre><br><br>        <p><strong>Stash commands:</strong></p><br>        <ul><br>            <li><code>git stash apply stash@{1}</code> - apply but keep in list</li><br>            <li><code>git stash pop stash@{1}</code> - apply and remove from list</li><br>            <li><code>git stash drop stash@{1}</code> - delete without applying</li><br>            <li><code>git stash clear</code> - delete all stashes</li><br>            <li><code>git stash show stash@{1}</code> - preview what's in a stash</li><br>        </ul>	cs git EN
What's the safest way to force push after rebasing your feature branch?	<strong>Command:</strong> <code>git push --force-with-lease</code><br><br>        <p><strong>Why --force-with-lease over --force:</strong> It only force pushes if no one else has pushed changes to the remote branch since your last fetch. Prevents accidentally overwriting someone else's work.</p><br><br>        <p><strong>When you need it:</strong></p><br>        <ul><br>            <li>After rebasing a feature branch</li><br>            <li>After amending pushed commits</li><br>            <li>After interactive rebase to clean up history</li><br>        </ul><br><br>        <p><strong>Scenario:</strong></p><br>        <pre><code>git rebase main<br>git push --force-with-lease origin feature-branch</code></pre><br><br>        <p><strong>Warning:</strong></p><br>        <ul><br>            <li>NEVER force push to main/master or shared branches</li><br>            <li>Only force push your own feature branches</li><br>            <li>Communicate with team if branch is shared</li><br>        </ul><br><br>        <p><strong>Plain --force:</strong> Nuclear option, use only if you're absolutely sure!</p>	cs git EN
How do you temporarily switch to a specific commit to test something, without creating a branch?	<strong>Command:</strong> <code>git checkout commit-hash</code><br><br>        <p><strong>Why:</strong> Enters "detached HEAD" state where HEAD points directly to a commit instead of a branch. Useful for testing old code or investigating bugs.</p><br><br>        <p><strong>Example:</strong></p><br>        <pre><code>git log --oneline           # Find commit hash<br>git checkout abc1234        # Go to that commit<br># Test, explore...<br>git checkout main           # Return to branch</code></pre><br><br>        <p><strong>Warning message you'll see:</strong> "You are in 'detached HEAD' state."</p><br><br>        <p><strong>If you make commits in detached HEAD:</strong></p><br>        <ul><br>            <li>They won't be on any branch</li><br>            <li>Create a branch to keep them: <code>git branch new-branch-name</code></li><br>            <li>Or they'll be lost when you checkout a branch</li><br>        </ul><br><br>        <p><strong>Return to branch:</strong></p><br>        <pre><code>git checkout main</code></pre>	cs git EN
You want to see a summary of all files changed between two commits. What's the command?	<strong>Command:</strong> <code>git diff --stat commit1 commit2</code><br><br>        <p><strong>Why:</strong> <code>--stat</code> gives a summary showing which files changed and how many lines were added/removed. Great for getting an overview without seeing all the code.</p><br><br>        <p><strong>Example output:</strong></p><br>        <pre><code> src/app.js       | 23 +++++---<br> src/utils.js     |  8 +--<br> README.md        |  5 ++<br> 3 files changed, 27 insertions(+), 9 deletions(-)</code></pre><br><br>        <p><strong>Variations:</strong></p><br>        <ul><br>            <li><code>git diff --stat main..feature</code> - compare branches</li><br>            <li><code>git diff --stat HEAD~5..HEAD</code> - last 5 commits</li><br>            <li><code>git diff --shortstat</code> - even more compact summary</li><br>            <li><code>git diff --name-only commit1 commit2</code> - just file names</li><br>        </ul><br><br>        <p><strong>For current changes:</strong></p><br>        <pre><code>git diff --stat</code></pre>	cs git EN
