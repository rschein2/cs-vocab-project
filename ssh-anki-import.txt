#deck:CS Vocab::SSH
#separator:tab
#html:true
#tags column:3

How do you connect to a remote server via SSH?	<strong>Command:</strong> <code>ssh username@hostname</code><br><br>        <p><strong>Examples:</strong></p><br>        <pre><code>ssh user@192.168.1.100<br>ssh admin@example.com<br>ssh root@server.company.com</code></pre><br><br>        <p><strong>Why this format:</strong> <code>username</code> is your account on the remote server, <code>hostname</code> is the server's address (IP or domain).</p><br><br>        <p><strong>If your local and remote usernames match:</strong></p><br>        <pre><code>ssh hostname</code></pre><br>        <p>SSH assumes you want to use the same username.</p><br><br>        <p><strong>Specify port (if not default 22):</strong></p><br>        <pre><code>ssh -p 2222 user@hostname</code></pre><br><br>        <p><strong>First connection:</strong> You'll be asked to verify the host fingerprint. Type "yes" to continue.</p>	cs ssh EN
How do you generate a new SSH key pair?	<strong>Command:</strong> <code>ssh-keygen</code><br><br>        <p><strong>Why:</strong> Creates a public/private key pair for passwordless authentication. More secure than passwords and essential for automated workflows.</p><br><br>        <p><strong>Interactive prompts:</strong></p><br>        <ul><br>            <li>File location (default: <code>~/.ssh/id_rsa</code>)</li><br>            <li>Passphrase (optional but recommended)</li><br>        </ul><br><br>        <p><strong>Better practice - specify key type:</strong></p><br>        <pre><code>ssh-keygen -t ed25519 -C "your_email@example.com"</code></pre><br><br>        <p><strong>Why ed25519:</strong> More secure and faster than RSA. Use RSA only for legacy systems:</p><br>        <pre><code>ssh-keygen -t rsa -b 4096 -C "your_email@example.com"</code></pre><br><br>        <p><strong>Output:</strong> Two files created:</p><br>        <ul><br>            <li><code>id_ed25519</code> - private key (NEVER share this!)</li><br>            <li><code>id_ed25519.pub</code> - public key (safe to share)</li><br>        </ul>	cs ssh EN
How do you copy your SSH public key to a remote server for passwordless login?	<strong>Command:</strong> <code>ssh-copy-id user@hostname</code><br><br>        <p><strong>Why:</strong> Automatically copies your public key to the server's <code>~/.ssh/authorized_keys</code> file with correct permissions. After this, you can log in without a password.</p><br><br>        <p><strong>Example:</strong></p><br>        <pre><code>ssh-copy-id user@example.com<br># Enter password one last time<br># Future logins are passwordless!</code></pre><br><br>        <p><strong>Specify which key:</strong></p><br>        <pre><code>ssh-copy-id -i ~/.ssh/id_ed25519.pub user@hostname</code></pre><br><br>        <p><strong>Manual method (if ssh-copy-id not available):</strong></p><br>        <pre><code>cat ~/.ssh/id_ed25519.pub | ssh user@host "mkdir -p ~/.ssh && cat >> ~/.ssh/authorized_keys"</code></pre><br><br>        <p><strong>Or even more manual:</strong></p><br>        <pre><code>scp ~/.ssh/id_ed25519.pub user@host:~/<br>ssh user@host<br>cat ~/id_ed25519.pub >> ~/.ssh/authorized_keys<br>chmod 600 ~/.ssh/authorized_keys</code></pre>	cs ssh EN
How do you create an SSH config file to simplify connection commands?	<strong>File location:</strong> <code>~/.ssh/config</code><br><br>        <p><strong>Why:</strong> Instead of typing <code>ssh user@really-long-hostname.com -p 2222 -i ~/.ssh/special_key</code>, you can just type <code>ssh myserver</code>.</p><br><br>        <p><strong>Example config:</strong></p><br>        <pre><code>Host myserver<br>    HostName example.com<br>    User myusername<br>    Port 22<br>    IdentityFile ~/.ssh/id_ed25519<br><br>Host work<br>    HostName 192.168.1.100<br>    User admin<br>    Port 2222</code></pre><br><br>        <p><strong>Then connect with:</strong></p><br>        <pre><code>ssh myserver<br>ssh work</code></pre><br><br>        <p><strong>Wildcards for multiple servers:</strong></p><br>        <pre><code>Host *.company.com<br>    User admin<br>    IdentityFile ~/.ssh/work_key</code></pre><br><br>        <p><strong>Pro tip:</strong> Set permissions correctly:</p><br>        <pre><code>chmod 600 ~/.ssh/config</code></pre>	cs ssh EN
How do you copy a file from your local machine to a remote server?	<strong>Command:</strong> <code>scp local-file user@host:/remote/path</code><br><br>        <p><strong>Why SCP:</strong> "Secure Copy" uses SSH protocol. Simple for one-off file transfers.</p><br><br>        <p><strong>Examples:</strong></p><br>        <pre><code>scp report.pdf user@server.com:/home/user/documents/<br>scp image.png user@192.168.1.100:~/Pictures/<br>scp -r folder/ user@host:/remote/path/  # Recursive for directories</code></pre><br><br>        <p><strong>Copy FROM remote TO local:</strong></p><br>        <pre><code>scp user@host:/remote/file.txt ~/local/path/</code></pre><br><br>        <p><strong>Copy between two remote servers:</strong></p><br>        <pre><code>scp user1@host1:/path/file user2@host2:/path/</code></pre><br><br>        <p><strong>Modern alternative (better for complex scenarios):</strong></p><br>        <pre><code>rsync -avz file user@host:/path/</code></pre><br>        <p>Rsync is smarter: only transfers changes, shows progress, can resume.</p>	cs ssh EN
How do you sync a directory to a remote server, only transferring changed files?	<strong>Command:</strong> <code>rsync -avz source/ user@host:/destination/</code><br><br>        <p><strong>Why rsync over scp:</strong> Only transfers differences. If you run it again, only new/changed files are copied. Much faster for repeated syncs!</p><br><br>        <p><strong>Flag meanings:</strong></p><br>        <ul><br>            <li><code>-a</code> - archive mode (preserves permissions, timestamps, etc.)</li><br>            <li><code>-v</code> - verbose (shows what's being transferred)</li><br>            <li><code>-z</code> - compress during transfer (faster over slow connections)</li><br>        </ul><br><br>        <p><strong>Important trailing slash:</strong></p><br>        <pre><code>rsync -avz source/ dest/    # Copies CONTENTS of source into dest<br>rsync -avz source dest/     # Copies source FOLDER into dest</code></pre><br><br>        <p><strong>Useful additions:</strong></p><br>        <pre><code>rsync -avz --progress source/ user@host:/dest/  # Show progress<br>rsync -avz --delete source/ user@host:/dest/    # Delete files in dest not in source<br>rsync -avzn source/ user@host:/dest/            # Dry run (preview changes)</code></pre>	cs ssh EN
How do you set up local port forwarding to access a remote service through SSH?	<strong>Command:</strong> <code>ssh -L local_port:destination:dest_port user@host</code><br><br>        <p><strong>Why:</strong> Access a service on the remote network as if it's running locally. Essential for accessing databases, web apps, or services behind firewalls.</p><br><br>        <p><strong>Example - access remote database:</strong></p><br>        <pre><code>ssh -L 3306:localhost:3306 user@server.com<br># Now connect to localhost:3306 on your machine<br># It tunnels to the database on server.com</code></pre><br><br>        <p><strong>Example - access internal web app:</strong></p><br>        <pre><code>ssh -L 8080:internal-server:80 user@gateway.com<br># Visit http://localhost:8080 in your browser<br># It shows the web app from internal-server:80</code></pre><br><br>        <p><strong>Keep SSH session open in background:</strong></p><br>        <pre><code>ssh -L 8080:target:80 user@host -N -f</code></pre><br>        <ul><br>            <li><code>-N</code> - don't execute remote commands (just forward)</li><br>            <li><code>-f</code> - go to background</li><br>        </ul>	cs ssh EN
How do you set up remote port forwarding to expose your local service to a remote server?	<strong>Command:</strong> <code>ssh -R remote_port:localhost:local_port user@host</code><br><br>        <p><strong>Why:</strong> Let people on the remote network access a service running on your local machine. Useful for demos, webhooks, or temporary access.</p><br><br>        <p><strong>Example - expose local web server:</strong></p><br>        <pre><code>ssh -R 8080:localhost:3000 user@server.com<br># Your local app on port 3000 is now accessible at<br># server.com:8080 to anyone on that network</code></pre><br><br>        <p><strong>Use case - testing webhooks:</strong></p><br>        <pre><code># You're developing locally on port 5000<br>ssh -R 9000:localhost:5000 user@publicserver.com<br># GitHub webhook can hit http://publicserver.com:9000<br># It tunnels to your local dev server!</code></pre><br><br>        <p><strong>Background mode:</strong></p><br>        <pre><code>ssh -R 8080:localhost:3000 user@host -N -f</code></pre><br><br>        <p><strong>Security note:</strong> Remote server must have <code>GatewayPorts yes</code> in <code>/etc/ssh/sshd_config</code> to allow external access.</p>	cs ssh EN
How do you run a single command on a remote server without starting an interactive session?	<strong>Command:</strong> <code>ssh user@host 'command'</code><br><br>        <p><strong>Why:</strong> Quick one-off commands without the overhead of an interactive session. Perfect for scripts and automation.</p><br><br>        <p><strong>Examples:</strong></p><br>        <pre><code>ssh user@server 'uptime'<br>ssh user@server 'df -h'<br>ssh user@server 'ls -la /var/log'<br>ssh user@server 'sudo systemctl restart nginx'</code></pre><br><br>        <p><strong>Multiple commands:</strong></p><br>        <pre><code>ssh user@host 'cd /app && git pull && npm restart'</code></pre><br><br>        <p><strong>Capture output locally:</strong></p><br>        <pre><code>ssh user@host 'cat /var/log/app.log' > local-log.txt<br>result=$(ssh user@host 'hostname')<br>echo "Connected to: $result"</code></pre><br><br>        <p><strong>With sudo (requires NOPASSWD or -t flag):</strong></p><br>        <pre><code>ssh -t user@host 'sudo command'</code></pre><br>        <p>The <code>-t</code> flag allocates a pseudo-terminal for sudo.</p>	cs ssh EN
What are the correct permissions for SSH keys and config files?	<strong>Critical permissions:</strong><br><br>        <pre><code>chmod 700 ~/.ssh                    # Directory<br>chmod 600 ~/.ssh/id_*               # Private keys<br>chmod 644 ~/.ssh/id_*.pub           # Public keys<br>chmod 600 ~/.ssh/config             # Config file<br>chmod 600 ~/.ssh/authorized_keys    # Authorized keys</code></pre><br><br>        <p><strong>Why these matter:</strong> SSH refuses to use keys with wrong permissions for security. Too permissive = potential security risk.</p><br><br>        <p><strong>Common error:</strong></p><br>        <pre><code>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br>@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @<br>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br>Permissions 0644 for '/home/user/.ssh/id_rsa' are too open.</code></pre><br><br>        <p><strong>Fix it:</strong></p><br>        <pre><code>chmod 600 ~/.ssh/id_rsa</code></pre><br><br>        <p><strong>Quick fix for entire .ssh directory:</strong></p><br>        <pre><code>chmod 700 ~/.ssh<br>chmod 600 ~/.ssh/*<br>chmod 644 ~/.ssh/*.pub</code></pre>	cs ssh EN
How do you start the SSH agent and add your key to it?	<strong>Commands:</strong><br>        <pre><code>eval "$(ssh-agent -s)"    # Start agent<br>ssh-add ~/.ssh/id_ed25519  # Add key</code></pre><br><br>        <p><strong>Why use ssh-agent:</strong> You unlock your key once (enter passphrase), and the agent remembers it for your entire session. No more typing passphrase for every SSH connection!</p><br><br>        <p><strong>Check loaded keys:</strong></p><br>        <pre><code>ssh-add -l</code></pre><br><br>        <p><strong>Add all default keys:</strong></p><br>        <pre><code>ssh-add</code></pre><br>        <p>Automatically finds and adds <code>id_rsa</code>, <code>id_ed25519</code>, etc.</p><br><br>        <p><strong>Remove all keys from agent:</strong></p><br>        <pre><code>ssh-add -D</code></pre><br><br>        <p><strong>Auto-start on login (add to ~/.bashrc or ~/.zshrc):</strong></p><br>        <pre><code>if [ -z "$SSH_AUTH_SOCK" ]; then<br>   eval "$(ssh-agent -s)"<br>   ssh-add<br>fi</code></pre>	cs ssh EN
How do you SSH through a jump host (bastion server) to reach an internal server?	<strong>Modern method:</strong> <code>ssh -J jump_user@jumphost final_user@destination</code><br><br>        <p><strong>Why jump hosts:</strong> Many networks have a single "bastion" server that's publicly accessible, and internal servers that aren't. You SSH to the bastion, then from there to internal servers.</p><br><br>        <p><strong>Example:</strong></p><br>        <pre><code>ssh -J user@bastion.com user@internal-server<br># Connects through bastion to reach internal-server</code></pre><br><br>        <p><strong>Multiple jump hosts:</strong></p><br>        <pre><code>ssh -J user@jump1,user@jump2 user@final-destination</code></pre><br><br>        <p><strong>In SSH config (~/.ssh/config):</strong></p><br>        <pre><code>Host internal<br>    HostName internal-server.local<br>    User admin<br>    ProxyJump bastion.com<br><br>Host bastion.com<br>    User jump_user</code></pre><br><br>        <p>Then just: <code>ssh internal</code></p><br><br>        <p><strong>Old method (still works):</strong></p><br>        <pre><code>ssh -o ProxyCommand="ssh -W %h:%p jump_user@jumphost" user@destination</code></pre>	cs ssh EN
How do you debug SSH connection problems with verbose output?	<strong>Command:</strong> <code>ssh -v user@host</code><br><br>        <p><strong>Why:</strong> Shows detailed connection steps: which keys are tried, authentication methods, connection stages. Essential for troubleshooting.</p><br><br>        <p><strong>Verbosity levels:</strong></p><br>        <ul><br>            <li><code>ssh -v</code> - verbose (most common)</li><br>            <li><code>ssh -vv</code> - very verbose</li><br>            <li><code>ssh -vvv</code> - extremely verbose (debug level)</li><br>        </ul><br><br>        <p><strong>What to look for in output:</strong></p><br>        <ul><br>            <li>"Offering public key..." - which keys are being tried</li><br>            <li>"Authentication succeeded" - what worked</li><br>            <li>"Permission denied" - what failed</li><br>            <li>"Connection refused" - can't reach server</li><br>            <li>"Host key verification failed" - known_hosts issue</li><br>        </ul><br><br>        <p><strong>Common issues revealed:</strong></p><br>        <ul><br>            <li>Wrong key being used</li><br>            <li>Key permissions too open</li><br>            <li>Server's authorized_keys misconfigured</li><br>            <li>Firewall blocking connection</li><br>        </ul>	cs ssh EN
How do you remove a host from your known_hosts file (when you get a "host key verification failed" warning)?	<strong>Command:</strong> <code>ssh-keygen -R hostname</code><br><br>        <p><strong>Why this happens:</strong> The server's host key changed (server was reinstalled, IP reassigned, or potential man-in-the-middle attack). SSH refuses to connect for security.</p><br><br>        <p><strong>Example:</strong></p><br>        <pre><code>ssh-keygen -R example.com<br>ssh-keygen -R 192.168.1.100</code></pre><br><br>        <p><strong>Manual method:</strong></p><br>        <pre><code>nano ~/.ssh/known_hosts<br># Delete the offending line<br># Or delete entire file: rm ~/.ssh/known_hosts</code></pre><br><br>        <p><strong>Skip host key checking (DANGEROUS - use only for testing):</strong></p><br>        <pre><code>ssh -o StrictHostKeyChecking=no user@host<br>ssh -o UserKnownHostsFile=/dev/null user@host</code></pre><br><br>        <p><strong>Why dangerous:</strong> Disables the main protection against man-in-the-middle attacks!</p><br><br>        <p><strong>Best practice:</strong> Verify the key change is legitimate before removing it.</p>	cs ssh EN
How do you keep an SSH connection alive to prevent timeout disconnections?	<strong>In SSH config (~/.ssh/config):</strong><br>        <pre><code>Host *<br>    ServerAliveInterval 60<br>    ServerAliveCountMax 3</code></pre><br><br>        <p><strong>Why:</strong> Many firewalls/routers drop "idle" SSH connections. These settings send keepalive packets every 60 seconds, preventing timeouts.</p><br><br>        <p><strong>What the settings mean:</strong></p><br>        <ul><br>            <li><code>ServerAliveInterval 60</code> - send keepalive every 60 seconds</li><br>            <li><code>ServerAliveCountMax 3</code> - disconnect after 3 failed keepalives (3 minutes of no response)</li><br>        </ul><br><br>        <p><strong>One-time use:</strong></p><br>        <pre><code>ssh -o ServerAliveInterval=60 user@host</code></pre><br><br>        <p><strong>Server-side equivalent (in /etc/ssh/sshd_config):</strong></p><br>        <pre><code>ClientAliveInterval 60<br>ClientAliveCountMax 3</code></pre><br><br>        <p><strong>Other useful SSH config options:</strong></p><br>        <pre><code>Host *<br>    ServerAliveInterval 60<br>    TCPKeepAlive yes<br>    Compression yes</code></pre>	cs ssh EN
How do you escape from a frozen SSH session without closing your terminal?	<strong>Command:</strong> <code>~.</code> (tilde followed by period)<br><br>        <p><strong>Why:</strong> Sometimes SSH sessions freeze (network issues, server hung). This escape sequence kills the connection from the client side.</p><br><br>        <p><strong>Important:</strong> Type <code>~</code> immediately after pressing Enter (at the start of a new line). Then type <code>.</code></p><br><br>        <p><strong>Other SSH escape sequences:</strong></p><br>        <ul><br>            <li><code>~.</code> - terminate connection (kill)</li><br>            <li><code>~^Z</code> - suspend SSH (background it, like Ctrl+Z)</li><br>            <li><code>~#</code> - list forwarded connections</li><br>            <li><code>~?</code> - show all escape sequences</li><br>            <li><code>~~</code> - send literal <code>~</code> character</li><br>        </ul><br><br>        <p><strong>When you see nothing after typing:</strong> Network is probably dead. Try <code>~.</code> to force disconnect.</p><br><br>        <p><strong>If even that doesn't work:</strong></p><br>        <ul><br>            <li>Close the terminal window, or</li><br>            <li>Find the SSH process and kill it: <code>pkill -9 ssh</code></li><br>        </ul>	cs ssh EN
How do you create an SSH tunnel that acts as a SOCKS proxy?	<strong>Command:</strong> <code>ssh -D local_port user@host</code><br><br>        <p><strong>Why:</strong> Creates a SOCKS5 proxy on your local machine. All traffic through this proxy is encrypted and tunneled through the SSH connection. Great for secure browsing or accessing region-restricted content.</p><br><br>        <p><strong>Example:</strong></p><br>        <pre><code>ssh -D 8080 user@server.com -N</code></pre><br><br>        <p><strong>Then configure your browser:</strong></p><br>        <ul><br>            <li>SOCKS Host: <code>localhost</code></li><br>            <li>Port: <code>8080</code></li><br>            <li>SOCKS v5</li><br>        </ul><br><br>        <p><strong>Now your browser traffic:</strong></p><br>        <ul><br>            <li>Encrypted end-to-end</li><br>            <li>Appears to come from the SSH server</li><br>            <li>Bypasses local network restrictions</li><br>        </ul><br><br>        <p><strong>Use case - secure public WiFi:</strong></p><br>        <pre><code># At coffee shop, connect to your home/VPS server<br>ssh -D 1080 user@home-server.com -N<br># Configure browser to use SOCKS proxy localhost:1080<br># All traffic is now encrypted through SSH</code></pre><br><br>        <p><strong>Background mode:</strong></p><br>        <pre><code>ssh -D 8080 user@host -N -f</code></pre>	cs ssh EN
How do you specify a different SSH key for a specific connection?	<strong>Command:</strong> <code>ssh -i /path/to/key user@host</code><br><br>        <p><strong>Why:</strong> You might have different keys for work, personal, different clients, etc. The <code>-i</code> flag tells SSH which key to use.</p><br><br>        <p><strong>Example:</strong></p><br>        <pre><code>ssh -i ~/.ssh/work_key user@work-server.com<br>ssh -i ~/.ssh/personal_key user@personal-vps.com<br>ssh -i ~/Downloads/client_key.pem ec2-user@aws-instance.com</code></pre><br><br>        <p><strong>Better approach - SSH config:</strong></p><br>        <pre><code>Host work<br>    HostName work-server.com<br>    User admin<br>    IdentityFile ~/.ssh/work_key<br><br>Host personal<br>    HostName personal-vps.com<br>    User myuser<br>    IdentityFile ~/.ssh/personal_key</code></pre><br><br>        <p>Then just: <code>ssh work</code> or <code>ssh personal</code></p><br><br>        <p><strong>Multiple keys for one host:</strong></p><br>        <pre><code>Host github.com<br>    IdentityFile ~/.ssh/github_personal<br>    IdentityFile ~/.ssh/github_work<br>    # Tries keys in order</code></pre>	cs ssh EN
How do you reuse an existing SSH connection (multiplexing) to speed up subsequent connections?	<strong>In SSH config (~/.ssh/config):</strong><br>        <pre><code>Host *<br>    ControlMaster auto<br>    ControlPath ~/.ssh/sockets/%r@%h:%p<br>    ControlPersist 10m</code></pre><br><br>        <p><strong>Why:</strong> The first SSH connection creates a master socket. Subsequent connections to the same host reuse it - instant connection, no re-authentication!</p><br><br>        <p><strong>Create the socket directory:</strong></p><br>        <pre><code>mkdir -p ~/.ssh/sockets</code></pre><br><br>        <p><strong>What each setting does:</strong></p><br>        <ul><br>            <li><code>ControlMaster auto</code> - automatically create/reuse master connections</li><br>            <li><code>ControlPath</code> - where to store socket files</li><br>            <li><code>ControlPersist 10m</code> - keep connection alive 10 minutes after last use</li><br>        </ul><br><br>        <p><strong>Benefits:</strong></p><br>        <ul><br>            <li>Instant subsequent connections (no SSH handshake)</li><br>            <li>No re-entering passwords/passphrases</li><br>            <li>Great for scp, rsync, git over SSH</li><br>        </ul><br><br>        <p><strong>Check active connections:</strong></p><br>        <pre><code>ssh -O check user@host</code></pre>	cs ssh EN
How do you disable password authentication and only allow key-based SSH login (server-side)?	<strong>Edit server config:</strong> <code>/etc/ssh/sshd_config</code><br><br>        <p><strong>Settings to change:</strong></p><br>        <pre><code>PasswordAuthentication no<br>PubkeyAuthentication yes<br>ChallengeResponseAuthentication no<br>UsePAM no</code></pre><br><br>        <p><strong>Why disable passwords:</strong></p><br>        <ul><br>            <li>Prevents brute force attacks</li><br>            <li>More secure than passwords</li><br>            <li>Industry best practice</li><br>        </ul><br><br>        <p><strong>IMPORTANT - before disabling passwords:</strong></p><br>        <ol><br>            <li>Add your public key to <code>~/.ssh/authorized_keys</code></li><br>            <li>Test key-based login in a separate session</li><br>            <li>Keep your current session open as backup</li><br>        </ol><br><br>        <p><strong>Restart SSH service after editing:</strong></p><br>        <pre><code>sudo systemctl restart sshd     # Most Linux<br>sudo service ssh restart        # Ubuntu/Debian</code></pre><br><br>        <p><strong>Other recommended hardening:</strong></p><br>        <pre><code>PermitRootLogin no              # Disable root login<br>Port 2222                       # Use non-standard port<br>AllowUsers username             # Only allow specific users</code></pre>	cs ssh EN
